<!DOCTYPE html>
<html lang="en">
	<head>
		
		<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1' />
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
		<title>Teoria de la Computación</title>

		<!-- Main CSS -->
		 <link href="css/DFA.css" rel="stylesheet">
		<!--link href="css/REGEX.css" rel="stylesheet">
		<!-- Bootstrap -->
		<link href="css/bootstrap.min.css" rel="stylesheet">

		<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		  <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->
	</head>


	<body>
		<nav class="navbar navbar-default">
		  <div class="container-fluid">
		    <div class="navbar-header">
		      <a class="navbar-brand" href="#">Teoria de la Computacion</a>
		    </div>
		    <ul class="nav navbar-nav">
		      <li ><a href="./index.html">Menu</a></li>
		      <li><a href="./DFA.html">DFA</a></li>
		      <li class="active"><a href="./REGEX.html">Regex</a></li>
		      <li><a href="./PDA.html">PDA</a></li> 
		    </ul>
		  </div>
		</nav>
		<div class="container">
		<div class="headerContainer">
		  <h1 align="center">Expresiones Regulares</h1>
		  <p>En el área de la programación las <strong>expresiones regulares</strong> son un método por medio del cual se pueden realizar búsquedas dentro de cadenas de caracteres. Sin importar la amplitud de la búsqueda requerida de un patrón definido de caracteres, las expresiones regulares proporcionan una solución práctica al problema. Adicionalmente, un uso derivado de la búsqueda de patrones es la validación de un formato específico en una cadena de caracteres dada, como por ejemplo fechas o identificadores.</p>
		  <h2>Definición formal</h2>
		  <p>R es una expresion regular si R:</p>
		  <ul>
			<li><strong>a</strong> para a&isin;&Sigma;</li>
			<li><strong>E</strong> </li>
			<li>&#216;</li>
			<li>R<sub>1</sub> U R<sub>2</sub> | R<sub>1</sub>^R<sub>2</sub> son expr.reg.</li>
			<li>R<sub>1</sub> o R<sub>2</sub> | R<sub>1</sub>^R<sub>2</sub> son expr.reg.</li>
			<li>R<sub>1</sub> | R<sub>1</sub> es expr.reg.</li>
		  </ul>
		</div>
		
		<div>
		 <label>Escriba expresiones regulares, ejemplo: a+b*, a*b*, a*b*bbc, [a|b]</label><br>
			<label for="regex">Regex:</label>
			<input id="regex" class="form-control" type="text" /><br><br>
		</div>
		<div>
			<label for="cadena">Cadena:</label>
			<input id="cadena" class="form-control" type="text" /><br><br>
		</div>
		
		<div>
			<button class="btn btn-default" type="submit" onclick="verificar_regex()">Verificar</button>
			<button class="btn btn-default" type="submit" onclick="RegularExpression(\'' + regEx + '\')">Convertir</button>
			<button class="btn btn-default" type="submit" onclick="LlenarEjemplo()">LlenarEjemplo1</button>
			<button class="btn btn-default" type="submit" onclick="LlenarEjemplo2()">LlenarEjemplo2</button>
			<button class="btn btn-default" type="submit" onclick="LlenarEjemplo3()">LlenarEjemplo3</button>
			<button class="btn btn-default" type="submit" onclick="LlenarEjemplo4()">LlenarEjemplo4</button><br>
			<button class="btn btn-default" name="agregar" type="image" id="agregar" onclick="Limpiar()" >Limpiar Datos </button>
			<button class="btn btn-default" type="submit" id="bDibujar" onclick="submitData();">Dibujar NFA</button>
		</div>
		
		<div>
			<label id="resultado"></label>
		</div>
		
		<div class="dfaCanvas">
		  <div id="cy"></div>
		  <div class="labelsContainer">
			<div class="dfaLabel rootNodeLabel"></div><span>Estado Inicial</span>
			<div class="dfaLabel finalNodeLabel"></div><span>Estado Final</span>
		  </div>
		  <div id="procesarCadenaForm">
			<div class="form-group"><label>Procesar Cadena: </label><input id="inputProcesar" class="form-control" type="text"/></div>
			<div class="form-group"><button class="btn btn-default" type="submit" id="btnProcesar" onclick="procesarCadena();">Procesar Cadena</button><button onclick="getBackForm()" class="btn btn-default">Volver</button></div>
		  </div>
		  <div id="DFA_Results"></div>
			<div id="AcceptedMessage">
			  <span style="color:green;">M se encuetra en un estado final, por lo cua M acepta la cadena "<span id="correctString"></span>"</span>
			  <button onclick="getBack()" class="btn btn-default">Volver</button>
			</div>
			<div id="DenniedMessage">
			  <span style="color:red;">M no se encuetra en un estado final, por lo cua M no acepta la cadena "<span id="wrongString"></span>"</span>
			  <button onclick="getBack()" class="btn btn-default">Volver</button>
			</div>
        </div>
		
			<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="js/bootstrap.min.js"></script>
		<script src="js/cytoscape.min.js"></script>
		<script src="js/NFA.js"></script>
		
		<script type="text/javascript">
			// Character matching token
			function CharacterToken(c) {
				this.c = c;
			}

			// Operator token for representing things like ?
			function OperatorToken(op) {
				this.op = op;
			}

			// A special concatenation token
			function ConcatenationToken() {
			}

			function convertToPostfix(re) {
				const outputQueue = [];

				// Convert a?a?aa into postfix notation
				//
				//        a
				//        a?
				//        a?a
				//        a?a?
				//        a?a?.a
				// Final: a?a?.a.a.

				let outstandingCharacterToken = 0;

				for (let i = 0; i < re.length; i++) {
					const c = re[i];
					switch (c) {
						case '?':
							// There should be an outstanding character token to apply this
							// to
							if (outstandingCharacterToken === 0) {
								throw new Error('Invalid regular expression.');
							}
							outputQueue.push(new OperatorToken(c));
							break;

						default:
							if (outstandingCharacterToken > 1) {
								outstandingCharacterToken--;
								outputQueue.push(new ConcatenationToken());
							}
							outputQueue.push(new CharacterToken(c));
							outstandingCharacterToken++;
							break;
					}
				}

				while (--outstandingCharacterToken > 0) {
					outputQueue.push(new ConcatenationToken());
				}

				return outputQueue;
			}

			function MatchState() {
			}

			function SplitState(outArrow1) {
				this.outArrows = [outArrow1, null];
			}

			function State(c) {
				this.c = c;
				this.outArrows = [null];
			}

			// Represents a combined but still incomplete NFA
			function Fragment(startState, incompleteOutArrows) {
				this.startState = startState;
				this.incompleteOutArrows = incompleteOutArrows;
			}

			// Represent one incomplete arrow coming out from the fragment
			function IncompleteArrow(state, arrowIndex) {
				this.state = state;
				this.arrowIndex = arrowIndex;
			}

			function connectArrowsToState(incompleteOutArrows, state) {
				while (incompleteOutArrows.length) {
					const incompleteArrow = incompleteOutArrows.pop();
					const arrowIndex = incompleteArrow.arrowIndex;
					incompleteArrow.state.outArrows[arrowIndex] = state;
				}
			}

			// Postfix tokens: a?a?.a.a.
			function convertToNFA(tokens) {
				const stack = [];

				tokens.forEach(token => {

					if (token instanceof ConcatenationToken) {
						// Incomplete NFA:
						//
						// >prevFragment1--->prevFragment2--->
						//
						const prevFragment2 = stack.pop();
						const prevFragment1 = stack.pop();
						connectArrowsToState(prevFragment1.incompleteOutArrows, prevFragment2.startState);
						const newFragment = new Fragment(prevFragment1.startState, prevFragment2.incompleteOutArrows);
						stack.push(newFragment);
					}
					else if (token instanceof OperatorToken && token.op === '?') {
						// Incomplete NFA:
						//  |->prevFragment->
						// >O
						//  |--------------->
						const prevFragment = stack.pop();

						// Construct a new fragment with out arrow #1 pointing to the
						// previous fragment's state
						const state = new SplitState(prevFragment.startState);
						const incompleteArrows = prevFragment.incompleteOutArrows;
						incompleteArrows.push(new IncompleteArrow(state, 1));
						const newFragment = new Fragment(state, incompleteArrows);
						stack.push(newFragment);
					}
					else if (token instanceof CharacterToken) {
						// Incomplete NFA:
						//
						// >O---->
						//
						const state = new State(token.c);
						const incompleteArrows = [
							new IncompleteArrow(state, 0)
						];
						const newFragment = new Fragment(state, incompleteArrows);
						stack.push(newFragment);
					}
				});

				const fragment = stack.pop();
				const matchState = new MatchState();
				connectArrowsToState(fragment.incompleteOutArrows, matchState);
				return fragment.startState;
			}
			
			function hasMatchState(states) {
				for (let i = 0; i < states.length; i++) {
					if (states[i] instanceof MatchState) {
						return true;
					}
				}
				return false;
			}

			function addState(statesList, state) {
				if (statesList.indexOf(state) >= 0) {
					return;
				}

				if (state instanceof SplitState) {
					addState(statesList, state.outArrows[0]);
					addState(statesList, state.outArrows[1]);
					return;
				}

				statesList.push(state);
			}

			function step(currentStates, character) {
				// Set of states the NFA will be in after processing the current character
				let nextStates = [];

				currentStates.forEach(state => {
					if (state instanceof State &&
						state.c === character) {

						addState(nextStates, state.outArrows[0]);
					}
				});

				return nextStates;
			}

			// Run NFA (with provided starting state) to determine whether it matches source
			function nfaMatches(state, inputText) {
				// Set of states the NFA is currently in
				let currentStates = [];
				addState(currentStates, state);

				for (let i = 0; i < inputText.length; i++) {
					const c = inputText[i];
					currentStates = step(currentStates, c);
				}

				// If after processing all the input text, we arrive at the MatchState then
				// it's a match!
				return hasMatchState(currentStates);
			}

			function RegularExpression(regEx) {
				this.regEx = regEx;
			}

			RegularExpression.prototype.test = function(source) {
				const tokens = convertToPostfix(this.regEx);
				const startState = convertToNFA(tokens);
				return nfaMatches(startState, source);
			};

			'use strict';

			const util = require('util');

			const n = process.argv[2];

			let source = '';
			let regEx = '';
			for (let i = 0; i < n; i++) {
				source += 'a';
				regEx += 'a?';
			}
			regEx += source;

			const re = new RegularExpression(regEx);

			const match = re.test(source);
			if (match) {
				//console.log('matches');
				console.log(document.getElementById( 'regex' ));
			}
			else {
				//console.log("doesn't match");
				console.log(document.getElementById( "doesn't regex "));
			}
			//console.log(document.getElementById( 'blah' ));
		</script>
		
		
		<script type="text/javascript">
			function Convertir()
			{
				var cy = cytoscape({
				  container: document.getElementById('cy')
				});
			
				var eles = regex.add([
				  { group: "nodes", data: { id: "a" }, position: { x: 100, y: 100 } },
				  { group: "nodes", data: { id: "b" }, position: { x: 200, y: 200 } },
				  { group: "nodes", data: { id: "c" }, position: { x: 300, y: 300 } },
				  { group: "nodes", data: { id: "d" }, position: { x: 400, y: 400 } },
				  { group: "edges", data: { id: "e0", source: "a", target: "b" } },
				  { group: "edges", data: { id: "e1", source: "c", target: "d" } }
				]);
				
				cy.remove( eles )
			}
			
			
			
		</script>
		
		<script type="text/javascript">
			function verificar_regex()
			{
				var regex = document.getElementById("regex").value;
				var pattern = new RegExp(regex);
				var cadena = document.getElementById("cadena").value;
				
				var capturedString = pattern.exec(cadena)[0];
				
				if(capturedString != null) {
					if(capturedString.length != cadena.length) {
						document.getElementById("resultado").innerHTML = "Rechaza";
					} else {
						document.getElementById("resultado").innerHTML = "Acepta";
					}
				}

			}
		</script>
		
		<script type="text/javascript">
			function LlenarEjemplo() {
				var input = document.getElementById('regex');
				input.value = input.value +'a+b*';
				
				var input2 = document.getElementById('cadena');
			    input2.value = input2.value +'abb';

			}
			function LlenarEjemplo2() {
				var input = document.getElementById('regex');
				input.value = input.value +'ab*';
				
				var input2 = document.getElementById('cadena');
			    input2.value = input2.value +'bbbbb';

			}
			function LlenarEjemplo3() {
				var input = document.getElementById('regex');
				input.value = input.value +'a*b*bbc';
				
				var input2 = document.getElementById('cadena');
			    input2.value = input2.value +'bbc';

			}
			function LlenarEjemplo4() {
				var input = document.getElementById('regex');
				input.value = input.value +'[a|b]';
				
				var input2 = document.getElementById('cadena');
			    input2.value = input2.value +'abbbbaa';

			}
			/*function stringAleatorio()
			{
				 var chars = "abc";
				 var string_length = 4;
				 var randomstring = document.getElementById("cadena");
				 
				 for (var i=0; i<string_length; i++) {
				  var rnum = Math.floor(Math.random() * chars.length);
				  randomstring.value += chars.substring(rnum,rnum+1);
				 }
				 
				 document.randform.randomfield.value = randomstring;
			}*/
		</script>   
		<script type="text/javascript">
			function Limpiar()
			{
				document.getElementById("regex").value="";
				document.getElementById("cadena").value="";
				//document.getElementById("resultado").value="";
			}
		</script>
		
		
		
	
	</body>
</html>